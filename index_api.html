<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EuroLeague Strength of Schedule</title>
</head>
<body>
<h1>EuroLeague Strength of Schedule</h1>
<pre id="output">Loading...</pre>

<script>
// --- UTILITY FUNCTIONS ---
function parseXMLToJSON(xml, itemTag) {
    const items = Array.from(xml.getElementsByTagName(itemTag));
    return items.map(item => {
        const obj = {};
        Array.from(item.children).forEach(child => {
            obj[child.tagName] = child.textContent;
        });
        return obj;
    });
}

function parseStandings(xml) {
    const group = xml.getElementsByTagName("group")[0];
    const teams = Array.from(group.getElementsByTagName("team"));
    const rows = teams.map(team => ({
        teamCode: team.getElementsByTagName("code")[0].textContent,
        teamName: team.getElementsByTagName("name")[0].textContent,
        ranking: parseInt(team.getElementsByTagName("ranking")[0].textContent),
    }));
    return rows;
}

function computeSOS(standings, futureGames, n_games = 5) {
    const rankings = {};
    standings.forEach(t => rankings[t.teamCode] = t.ranking);
    const teams = standings.map(t => t.teamCode);

    const results = [];

    teams.forEach(team => {
        // Filter future games where the team plays
        const homeGames = futureGames.filter(g => g.homecode === team)
            .map(g => ({...g, opponent: g.awaycode}));
        const awayGames = futureGames.filter(g => g.awaycode === team)
            .map(g => ({...g, opponent: g.homecode}));

        const nextGames = [...homeGames, ...awayGames]
            .sort((a,b) => new Date(a.date) - new Date(b.date))
            .slice(0, n_games);

        if(nextGames.length === 0) {
            results.push({teamCode: team, teamName: standings.find(s => s.teamCode === team).teamName, SOS: null, gamesRemaining: 0});
            return;
        }

        const oppRankings = nextGames.map(g => rankings[g.opponent] || 0);
        const sos = oppRankings.reduce((a,b) => a+b,0)/oppRankings.length;

        results.push({
            teamCode: team,
            teamName: standings.find(s => s.teamCode === team).teamName,
            SOS: sos.toFixed(2),
            gamesRemaining: nextGames.length,
            opponents: nextGames.map(g => g.opponent),
            opponentRankings: oppRankings,
            gameDates: nextGames.map(g => g.date),
            gameCodes: nextGames.map(g => g.gamecode)
        });
    });

    // Sort by SOS ascending
    return results.sort((a,b) => a.SOS - b.SOS);
}

// --- MAIN FUNCTION ---
async function main() {
    const SEASON_CODE = "E2025";

    // --- Fetch future games ---
    const gamesRes = await fetch(`https://api-live.euroleague.net/v1/schedules?seasonCode=${SEASON_CODE}`);
    const gamesText = await gamesRes.text();
    const gamesXML = new DOMParser().parseFromString(gamesText, "text/xml");

    const futureGames = parseXMLToJSON(gamesXML, "item")
        .map(g => ({...g, played: g.played === "true"}))
        .filter(g => !g.played);

    // --- Fetch standings ---
    const standingsRes = await fetch(`https://api-live.euroleague.net/v1/standings?seasonCode=${SEASON_CODE}`);
    const standingsText = await standingsRes.text();
    const standingsXML = new DOMParser().parseFromString(standingsText, "text/xml");
    const standings = parseStandings(standingsXML);

    // --- Compute SOS ---
    const sos = computeSOS(standings, futureGames, 5);

    document.getElementById("output").textContent = JSON.stringify(sos, null, 2);
}

// Run
main().catch(err => console.error(err));
</script>

</body>
</html>
