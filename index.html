<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>EuroLeague Strength of Schedule</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <h1>EuroLeague Strength of Schedule</h1>
  <div id="output"></div>

  <!-- Canvas for SOS plot -->
  <canvas id="sosPlot" height="300" style="margin-top: 30px; border:1px solid #ccc;"></canvas>

  <script>
    async function loadJSON(url) {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Failed to fetch ${url}`);
      return response.json();
    }

    function computeSOS(standings, futureGames, nGames = 5) {
      const rankings = {};
      standings.forEach(team => { rankings[team.teamCode] = team.ranking; });

      const results = standings.map(team => {
        const code = team.teamCode;

        const homeGames = futureGames.filter(g => g.homecode === code)
          .map(g => ({ opponent: g.awaycode, date: new Date(g.date), gamecode: g.gamecode }));
        const awayGames = futureGames.filter(g => g.awaycode === code)
          .map(g => ({ opponent: g.homecode, date: new Date(g.date), gamecode: g.gamecode }));

        const nextGames = [...homeGames, ...awayGames]
          .sort((a,b) => a.date - b.date)
          .slice(0, nGames);

        if (nextGames.length === 0) {
          return {
            teamCode: code,
            teamName: team.teamName,
            SOS: null,
            gamesRemaining: 0,
            opponents: [],
            opponentRankings: [],
            gameDates: [],
            gameCodes: []
          };
        }

        const oppCodes = nextGames.map(g => g.opponent);
        const oppRankings = oppCodes.map(c => rankings[c] || null);
        const sos = oppRankings.reduce((a,b) => a + b, 0) / oppRankings.length;

        return {
          teamCode: code,
          teamName: team.teamName,
          SOS: sos,
          gamesRemaining: nextGames.length,
          opponents: oppCodes,
          opponentRankings: oppRankings,
          gameDates: nextGames.map(g => g.date.toISOString()),
          gameCodes: nextGames.map(g => g.gamecode)
        };
      });

      results.sort((a,b) => (a.SOS || 0) - (b.SOS || 0));
      return results;
    }

    function renderTable(data) {
      if (data.length === 0) return "<p>No data available</p>";

      let html = `<table id="sosTable">
        <thead>
          <tr>
            <th>#</th>
            <th>Team Name</th>
            <th>SOS</th>
            <th>Opponents</th>
            <th>Opponent Rankings</th>
          </tr>
        </thead>
        <tbody>`;

      data.forEach((team, index) => {
        html += `<tr>
          <td>${index + 1}</td>
          <td>${team.teamName}</td>
          <td>${team.SOS !== null ? team.SOS.toFixed(2) : "N/A"}</td>
          <td>${team.opponents.join(", ")}</td>
          <td>${team.opponentRankings.join(", ")}</td>
        </tr>`;
      });

      html += "</tbody></table>";
      return html;
    }

    function drawSOSPlot(data) {
      const canvas = document.getElementById("sosPlot");
      const table = document.getElementById("sosTable");

      // Make canvas width match the table width
      canvas.width = table.offsetWidth;

      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      if (data.length === 0) return;

      const padding = 40;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      const maxSOS = Math.max(...data.map(d => d.SOS || 0));
      const stepX = plotWidth / data.length;

      ctx.fillStyle = "#007bff";
      ctx.strokeStyle = "#333";
      ctx.font = "12px Arial";
      ctx.textAlign = "center";

      // Axes
      ctx.beginPath();
      ctx.moveTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.stroke();

      // Dots and labels
      data.forEach((team, i) => {
        const x = padding + i * stepX + stepX / 2;
        const y = height - padding - ((team.SOS || 0) / maxSOS) * plotHeight;

        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fill();

        ctx.fillText(team.teamCode, x, y - 10);
        ctx.fillText(team.SOS !== null ? team.SOS.toFixed(2) : "N/A", x, y - 22);
      });

      // Y-axis labels
      ctx.textAlign = "right";
      ctx.fillStyle = "#000";
      for (let i = 0; i <= maxSOS; i += Math.ceil(maxSOS/5)) {
        const y = height - padding - (i / maxSOS) * plotHeight;
        ctx.fillText(i, padding - 5, y + 4);
      }
    }

    async function main() {
      try {
        const [standings, futureGames] = await Promise.all([
          loadJSON('standings.json'),
          loadJSON('future_games.json')
        ]);

        const sos = computeSOS(standings, futureGames, 5);

        const output = document.getElementById('output');
        output.innerHTML = renderTable(sos);

        drawSOSPlot(sos);

      } catch (err) {
        console.error(err);
      }
    }

    window.addEventListener("resize", main); // Re-draw on resize
    main();
  </script>
</body>
</html>
