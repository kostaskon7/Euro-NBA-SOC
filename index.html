<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>EuroLeague Strength of Schedule</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    th {
      cursor: pointer;
      background-color: #0077cc; /* blue headers */
      color: white;
      padding: 8px 12px;
      text-align: center;
    }
    th.sorted-asc::after { content: " ▲"; }
    th.sorted-desc::after { content: " ▼"; }
    table {
      border-collapse: collapse;
      margin: 20px auto;
      width: 90%;
    }
    td {
      padding: 8px 12px;
      text-align: center;
      border: 1px solid #ccc;
    }
    canvas {
      display: block;
      margin: 30px auto;
      width: 90%;
      height: 300px;
      max-width: 1200px;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <h1>EuroLeague Strength of Schedule</h1>
  <div style="margin-bottom:20px; text-align:center;">
    <label for="gamesSlider"><b>Select number of upcoming games:</b></label><br>
    <input type="range" id="gamesSlider" min="1" value="5" step="1">
    <span id="gamesValue">10</span>
  </div>

  <div id="output"></div>

  <canvas id="sosPlot" height="300"></canvas>

  <script>
    async function loadJSON(url) {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Failed to fetch ${url}`);
      return response.json();
    }

    function computeSOS(standings, futureGames, nGames = 5) {
      const rankingsMap = {};
      standings.forEach(team => { rankingsMap[team.teamCode] = team.ranking; });

      const results = standings.map(team => {
        const code = team.teamCode;

        const homeGames = futureGames.filter(g => g.homecode === code)
          .map(g => ({ opponent: g.awaycode, date: new Date(g.date), gamecode: g.gamecode }));
        const awayGames = futureGames.filter(g => g.awaycode === code)
          .map(g => ({ opponent: g.homecode, date: new Date(g.date), gamecode: g.gamecode }));

        const nextGames = [...homeGames, ...awayGames].sort((a,b) => a.date - b.date).slice(0, nGames);

        if (!nextGames.length) {
          return {
            teamCode: code,
            teamName: team.teamName,
            SOS: null,
            Ranking: team.ranking,
            opponents: [],
            opponentRankings: []
          };
        }

        const oppCodes = nextGames.map(g => g.opponent);
        const oppRankings = oppCodes.map(c => rankingsMap[c] || null);
        const sos = oppRankings.reduce((a,b) => a+b, 0)/oppRankings.length;

        return {
          teamCode: code,
          teamName: team.teamName,
          SOS: sos,
          Ranking: team.ranking,
          opponents: oppCodes,
          opponentRankings: oppRankings
        };
      });

      results.sort((a,b) => (a.SOS || 0) - (b.SOS || 0));
      return results;
    }

    function renderTable(data) {
        if (!data.length) return "<p>No data available</p>";

        let html = `<table id="sosTable">
            <thead>
            <tr>
                <th>#</th>
                <th>Team Name</th>
                <th>SOS</th>
                <th>Ranking</th>
                <th>Opponents</th>
                <th>Opponent Rankings</th>
            </tr>
            </thead>
            <tbody>`;

        data.forEach((team,index) => {
            // Limit to first 10 items
            const opps = team.opponents.slice(0, 8).join(", ");
            const oppRanks = team.opponentRankings.slice(0, 8).join(", ");

            html += `<tr>
            <td>${index+1}</td>
            <td>${team.teamName}</td>
            <td>${team.SOS !== null ? team.SOS.toFixed(2) : "N/A"}</td>
            <td>${team.Ranking}</td>
            <td>${opps}</td>
            <td>${oppRanks}</td>
            </tr>`;
        });

        html += "</tbody></table>";
        return html;
    }

    function makeTableSortable(tableId) {
      const table = document.getElementById(tableId);
      const headers = table.querySelectorAll("th");
      headers.forEach((th, idx) => {
        th.addEventListener("click", () => {
          const tbody = table.querySelector("tbody");
          const rows = Array.from(tbody.querySelectorAll("tr"));
          const isNumeric = idx === 2 || idx === 3; // SOS or Ranking
          const currentDir = th.classList.contains("sorted-asc") ? "asc" : "desc";

          rows.sort((a,b) => {
            const aVal = a.children[idx].textContent;
            const bVal = b.children[idx].textContent;
            if (isNumeric) {
              return currentDir === "asc" ? parseFloat(aVal) - parseFloat(bVal) : parseFloat(bVal) - parseFloat(aVal);
            } else {
              return currentDir === "asc" ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            }
          });

          tbody.innerHTML = "";
          rows.forEach(r => tbody.appendChild(r));

          headers.forEach(h => h.classList.remove("sorted-asc","sorted-desc"));
          th.classList.add(currentDir === "asc" ? "sorted-desc" : "sorted-asc");
        });
      });
    }

    function drawSOSPlot(data) {
        const canvas = document.getElementById("sosPlot");
        const table = document.getElementById("sosTable");
        canvas.width = table.offsetWidth; // dynamic width
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);
        if (!data.length) return;

        const padding = 40;
        const plotWidth = width - padding*2;
        const plotHeight = height - padding*2;
        const maxSOS = Math.max(...data.map(d => d.SOS || 0));
        const stepX = plotWidth / data.length;

        ctx.fillStyle = "#0077cc";
        ctx.strokeStyle = "#333";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";

        // Axes
        ctx.beginPath();
        ctx.moveTo(padding, height - padding);
        ctx.lineTo(width - padding, height - padding);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding);
        ctx.stroke();

        // Dots with Team Code and SOS
        data.forEach((team, i) => {
            const x = padding + i*stepX + stepX/2;
            const y = height - padding - ((team.SOS||0)/maxSOS)*plotHeight;

            // Dot
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, 2*Math.PI);
            ctx.fill();

            // Team code above dot
            ctx.fillStyle = "#000";
            ctx.fillText(team.teamCode, x, y - 14);

            // SOS value above team code
            ctx.fillText(team.SOS !== null ? team.SOS.toFixed(2) : "N/A", x, y - 28);

            ctx.fillStyle = "#0077cc"; // reset dot color
        });

        // Y-axis labels
        ctx.textAlign = "right";
        ctx.fillStyle = "#000";
        for (let i = 0; i <= maxSOS; i += Math.ceil(maxSOS/5)) {
            const y = height - padding - (i / maxSOS) * plotHeight;
            ctx.fillText(i, padding - 5, y + 4);
        }
    }
    function updateSOS(standings, futureGames) {
      const nGames = parseInt(document.getElementById("gamesSlider").value);
      const sos = computeSOS(standings, futureGames, nGames);

      const output = document.getElementById("output");
      output.innerHTML = renderTable(sos);
      makeTableSortable("sosTable");
      drawSOSPlot(sos);
    }

    // Determine max number of upcoming games for any team
    function maxGamesPerTeam(futureGames) {
      const teamCounts = {};

      futureGames.forEach(g => {
        teamCounts[g.homecode] = (teamCounts[g.homecode] || 0) + 1;
        teamCounts[g.awaycode] = (teamCounts[g.awaycode] || 0) + 1;
      });

      return Math.max(...Object.values(teamCounts));
    }


    let globalStandings = null;
    let globalFutureGames = null;

    async function main() {
      try {
        const [standings, futureGames] = await Promise.all([
          loadJSON("/.netlify/functions/future_games"),
          loadJSON("/.netlify/functions/standings")
        ]);

        globalStandings = standings;
        globalFutureGames = futureGames;

        // --- (1) NEW: compute max games per team ---
        const teamCounts = {};
        futureGames.forEach(g => {
          teamCounts[g.homecode] = (teamCounts[g.homecode] || 0) + 1;
          teamCounts[g.awaycode] = (teamCounts[g.awaycode] || 0) + 1;
        });
        const maxGames = Math.max(...Object.values(teamCounts));

        // --- (2) NEW: apply to slider ---
        const slider = document.getElementById("gamesSlider");
        slider.max = maxGames;
        slider.value = Math.min(5, maxGames);
        if (parseInt(slider.value) > maxGames) slider.value = maxGames;
        document.getElementById("gamesValue").textContent = slider.value;
        // ---------------------------------------------------------------

        // Initial render with default slider value
        updateSOS(globalStandings, globalFutureGames);

        // Update when slider moves
        // document.getElementById("gamesSlider").addEventListener("input", () => {
        //   document.getElementById("gamesValue").textContent =
        //     document.getElementById("gamesSlider").value;
        //   updateSOS(globalStandings, globalFutureGames);
        // });
        let sliderTimeout;
        document.getElementById("gamesSlider").addEventListener("input", () => {
          clearTimeout(sliderTimeout);
          sliderTimeout = setTimeout(() => {
            document.getElementById("gamesValue").textContent =
              document.getElementById("gamesSlider").value;
            updateSOS(globalStandings, globalFutureGames);
          }, 100); // only run after 100ms of no movement
        });


      } catch (err) {
        console.error(err);
      }
    }


    window.addEventListener("resize", () => {
      if (globalStandings && globalFutureGames) {
        updateSOS(globalStandings, globalFutureGames);
      }
    });

    main();

  </script>
</body>
</html>
