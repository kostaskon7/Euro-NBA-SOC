<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EuroLeague Strength of Schedule</title>
  <link rel="stylesheet" href="styles.css">
  
  <!-- React and Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // Main App Component
    function App() {
      const [standings, setStandings] = useState(null);
      const [futureGames, setFutureGames] = useState(null);
      const [nGames, setNGames] = useState(5);
      const [maxGames, setMaxGames] = useState(10);
      const [sortConfig, setSortConfig] = useState({ column: null, direction: 'asc' });
      const canvasRef = useRef(null);
      const tableRef = useRef(null);
      const chartCardRef = useRef(null);

      // Load data
      useEffect(() => {
        async function loadData() {
          try {
            const [standingsData, futureGamesData] = await Promise.all([
              fetch("/.netlify/functions/standings").then(r => r.json()),
              fetch("/.netlify/functions/future_games").then(r => r.json())
            ]);

            setStandings(standingsData);
            setFutureGames(futureGamesData);

            // Calculate max games
            const teamCounts = {};
            futureGamesData.forEach(g => {
              teamCounts[g.homecode] = (teamCounts[g.homecode] || 0) + 1;
              teamCounts[g.awaycode] = (teamCounts[g.awaycode] || 0) + 1;
            });
            const max = Math.max(...Object.values(teamCounts));
            setMaxGames(max);
            setNGames(Math.min(5, max));
          } catch (err) {
            console.error(err);
          }
        }
        loadData();
      }, []);

      // Compute SOS
      const computeSOS = useCallback((standings, futureGames, nGames) => {
        if (!standings || !futureGames) return [];
        
        const rankingsMap = {};
        standings.forEach(team => { rankingsMap[team.teamCode] = team.ranking; });

        const results = standings.map(team => {
          const code = team.teamCode;
          const homeGames = futureGames.filter(g => g.homecode === code)
            .map(g => ({ opponent: g.awaycode, date: new Date(g.date), gamecode: g.gamecode, isHome: true }));
          const awayGames = futureGames.filter(g => g.awaycode === code)
            .map(g => ({ opponent: g.homecode, date: new Date(g.date), gamecode: g.gamecode, isHome: false }));

          const nextGames = [...homeGames, ...awayGames].sort((a,b) => a.date - b.date).slice(0, nGames);

          if (!nextGames.length) {
            return {
              teamCode: code,
              teamName: team.teamName,
              SOS: null,
              Ranking: team.ranking,
              opponents: [],
              opponentRankings: [],
              opponentHomeAway: []
            };
          }

          const oppCodes = nextGames.map(g => g.opponent);
          const oppRankings = oppCodes.map(c => rankingsMap[c] || null);
          const oppHomeAway = nextGames.map(g => g.isHome ? 'H' : 'A');
          const sos = oppRankings.reduce((a,b) => a+b, 0)/oppRankings.length;

          return {
            teamCode: code,
            teamName: team.teamName,
            SOS: sos,
            Ranking: team.ranking,
            opponents: oppCodes,
            opponentRankings: oppRankings,
            opponentHomeAway: oppHomeAway
          };
        });

        return results.sort((a,b) => (a.SOS || 0) - (b.SOS || 0));
      }, []);

      // Get sorted data
      const getSortedData = useCallback(() => {
        if (!standings || !futureGames) return [];
        
        let data = computeSOS(standings, futureGames, nGames);
        
        if (sortConfig.column !== null) {
          const { column, direction } = sortConfig;
          data = [...data].sort((a, b) => {
            let aVal, bVal;
            
            switch(column) {
              case 0: // #
                aVal = data.indexOf(a);
                bVal = data.indexOf(b);
                break;
              case 1: // Team Name
                aVal = a.teamName;
                bVal = b.teamName;
                break;
              case 2: // SOS
                aVal = a.SOS !== null ? a.SOS : 0;
                bVal = b.SOS !== null ? b.SOS : 0;
                break;
              case 3: // Ranking
                aVal = a.Ranking;
                bVal = b.Ranking;
                break;
              default:
                return 0;
            }
            
            if (typeof aVal === 'number') {
              return direction === 'asc' ? aVal - bVal : bVal - aVal;
            } else {
              return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            }
          });
        }
        
        return data;
      }, [standings, futureGames, nGames, sortConfig, computeSOS]);

      // Handle sort
      const handleSort = (columnIndex) => {
        setSortConfig(prev => ({
          column: columnIndex,
          direction: prev.column === columnIndex && prev.direction === 'asc' ? 'desc' : 'asc'
        }));
      };

      // Draw chart helper function
      const drawChart = useCallback((data) => {
        if (!canvasRef.current || !data.length) return;

        const canvas = canvasRef.current;
        // Get width from table if available, otherwise use chart card or default
        let width = 800; // default width
        if (tableRef.current && tableRef.current.offsetWidth > 0) {
          width = tableRef.current.offsetWidth;
        } else if (chartCardRef.current) {
          width = chartCardRef.current.offsetWidth - 64; // account for padding (2rem = 32px * 2)
        } else if (canvas.parentElement) {
          width = canvas.parentElement.offsetWidth - 64;
        }
        
        // Ensure minimum width
        width = Math.max(width, 400);
        
        canvas.width = width;
        canvas.style.width = '100%';
        const ctx = canvas.getContext("2d");
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        const padding = 50;
        const plotWidth = width - padding * 2;
        const plotHeight = height - padding * 2;
        const maxSOS = Math.max(...data.map(d => d.SOS || 0));
        if (maxSOS === 0) return;
        const stepX = plotWidth / data.length;

        // Modern gradient background
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, 'rgba(0, 119, 204, 0.05)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);

        // Axes with modern styling
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(padding, height - padding);
        ctx.lineTo(width - padding, height - padding);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding);
        ctx.stroke();

        // Grid lines
        ctx.strokeStyle = '#f0f0f0';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 5; i++) {
          const y = height - padding - (i / 5) * plotHeight;
          ctx.beginPath();
          ctx.moveTo(padding, y);
          ctx.lineTo(width - padding, y);
          ctx.stroke();
        }

        // Data points with team logos
        const logoSize = 32;
        let loadedImages = 0;
        const totalImages = data.length;
        
        data.forEach((team, i) => {
          const x = padding + i * stepX + stepX / 2;
          const y = height - padding - ((team.SOS || 0) / maxSOS) * plotHeight;
          
          const img = new Image();
          img.crossOrigin = 'anonymous';
          
          img.onload = () => {
            // Draw team logo with shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 6;
            ctx.shadowOffsetY = 2;
            
            // Draw logo
            ctx.drawImage(img, x - logoSize / 2, y - logoSize / 2, logoSize, logoSize);
            
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;

            // SOS value below logo
            ctx.fillStyle = '#666';
            ctx.font = '10px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(team.SOS !== null ? team.SOS.toFixed(2) : "N/A", x, y + logoSize / 2 + 14);
            
            loadedImages++;
          };
          
          img.onerror = () => {
            // Fallback: draw a circle if image fails to load
            ctx.shadowColor = 'rgba(0, 119, 204, 0.3)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetY = 2;
            
            const dotGradient = ctx.createRadialGradient(x, y, 0, x, y, 8);
            dotGradient.addColorStop(0, '#0077cc');
            dotGradient.addColorStop(1, '#005599');
            ctx.fillStyle = dotGradient;
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;

            // SOS value below dot
            ctx.fillStyle = '#666';
            ctx.font = '10px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(team.SOS !== null ? team.SOS.toFixed(2) : "N/A", x, y + 20);
            
            loadedImages++;
          };
          
          img.src = `photos/team logos/${team.teamCode}.webp`;
        });

        // Y-axis labels
        ctx.textAlign = "right";
        ctx.fillStyle = "#666";
        ctx.font = '11px "Segoe UI", sans-serif';
        for (let i = 0; i <= 5; i++) {
          const value = (i / 5) * maxSOS;
          const y = height - padding - (i / 5) * plotHeight;
          ctx.fillText(value.toFixed(1), padding - 10, y + 4);
        }
      }, []);

      const sosData = getSortedData();

      // Draw chart when data changes
      useEffect(() => {
        if (sosData.length) {
          // Use setTimeout to ensure DOM is ready
          setTimeout(() => {
            drawChart(sosData);
          }, 100);
        }
      }, [sosData, drawChart]);

      // Handle resize
      useEffect(() => {
        const handleResize = () => {
          if (sosData.length) {
            setTimeout(() => drawChart(sosData), 100);
          }
        };
        window.addEventListener("resize", handleResize);
        return () => window.removeEventListener("resize", handleResize);
      }, [sosData, drawChart]);

      return (
        <div className="app-container">
          <header className="app-header">
            <h1>EuroLeague Strength of Schedule</h1>
            <p className="subtitle">Analyze upcoming game difficulty for each team</p>
          </header>

          <div className="controls-card">
            <label htmlFor="gamesSlider" className="slider-label">
              <span className="slider-label-text">Select number of upcoming games</span>
              <span className="slider-value">{nGames}</span>
            </label>
            <input
              type="range"
              id="gamesSlider"
              min="1"
              max={maxGames}
              value={nGames}
              onChange={(e) => setNGames(parseInt(e.target.value))}
              className="modern-slider"
            />
          </div>

          {sosData.length > 0 && (
            <>
              <div className="table-card" ref={tableRef}>
                <SOSTable data={sosData} onSort={handleSort} sortConfig={sortConfig} />
              </div>

              <div className="chart-card" ref={chartCardRef}>
                <h2 className="chart-title">SOS Visualization</h2>
                <canvas ref={canvasRef} id="sosPlot" height="300" className="modern-chart"></canvas>
              </div>
            </>
          )}

          {!standings && (
            <div className="loading-state">
              <div className="spinner"></div>
              <p>Loading data...</p>
            </div>
          )}
        </div>
      );
    }

    // Table Component
    function SOSTable({ data, onSort, sortConfig }) {
      const getSortIcon = (columnIndex) => {
        if (sortConfig.column !== columnIndex) return '↕️';
        return sortConfig.direction === 'asc' ? '▲' : '▼';
      };

      return (
        <table id="sosTable" className="modern-table">
          <thead>
            <tr>
              <th onClick={() => onSort(0)} className="sortable">
                # {getSortIcon(0)}
              </th>
              <th onClick={() => onSort(1)} className="sortable">
                Team Name {getSortIcon(1)}
              </th>
              <th onClick={() => onSort(2)} className="sortable">
                SOS {getSortIcon(2)}
              </th>
              <th onClick={() => onSort(3)} className="sortable">
                Ranking {getSortIcon(3)}
              </th>
              <th>Opponents</th>
              <th>Opponent Rankings</th>
            </tr>
          </thead>
          <tbody>
            {data.map((team, index) => (
              <tr key={team.teamCode}>
                <td className="rank-cell">{index + 1}</td>
                <td className="team-name-cell">
                  <span>{team.teamName}</span>
                  <img
                    src={`photos/team logos/${team.teamCode}.webp`}
                    className="team-logo"
                    alt={team.teamCode}
                  />
                </td>
                <td className="sos-cell">
                  {team.SOS !== null ? (
                    <span className="sos-value">{team.SOS.toFixed(2)}</span>
                  ) : (
                    <span className="na-badge">N/A</span>
                  )}
                </td>
                <td className="ranking-cell">{team.Ranking}</td>
                <td className="opponents-cell">
                  {team.opponents.slice(0, 8).map((code, i) => {
                    const homeAway = team.opponentHomeAway && team.opponentHomeAway[i] ? team.opponentHomeAway[i] : '';
                    return (
                      <span key={i} style={{ display: 'inline-flex', alignItems: 'center', marginRight: '4px' }}>
                        <img
                          src={`photos/team logos/${code}.webp`}
                          className="team-logo"
                          alt={code}
                        />
                        {homeAway && (
                          <span className="home-away-badge" title={homeAway === 'H' ? 'Home' : 'Away'}>
                            {homeAway}
                          </span>
                        )}
                      </span>
                    );
                  })}
                </td>
                <td className="opponent-ranks-cell">
                  {team.opponentRankings.slice(0, 8).join(", ")}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      );
    }

    // Render App
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
